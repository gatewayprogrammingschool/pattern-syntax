%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Pattern
file_extensions:
  - pattern
first_line_match: "Pattern File"

scope: source.pattern
variables:
  number_number: '((\d+)(\.?)(\d*))'
  number_hex: '(((?:0[xX]+)|[$])([a-fA-F0-9]+))'
  string: '("[^"]*")'

  bool_op_equality: '(?:==|Is)'
  bool_op_logical_and: '(?:&&|And)'
  bool_op_logical_or: '(?:\|\||Or)'
  bool_op_logical_not: '(?:!|Not)'
  bool_op_xor: '(?:\^|Xor)'
  bool_op: '(?:({{bool_op_equality}}|{{bool_op_logical_and}}|{{bool_op_logical_not}}|{{bool_op_logical_or}}|{{bool_op_xor}}))'

  assignment_op_direct: '(?:=|From)'
  assignment_op_and: '(?:&)'
  assignment_op_or: '(?:\|)'
  assignment_op: '(?:({{assignment_op_and}}|{{assignment_op_or}}))'

  math_op_addition: '(?:[+])'
  math_op_subtraction: '(?:[-])' 
  math_op_multiplication: '(?:[*])'
  math_op_division: '(?:[/])'
  math_op_remainder: '(?:[%])'
  math_op_power: '(?:^)'
  math_op_root: '(?:[\#])'
  math_op: '(?:{{math_op_addition}}|{{math_op_division}}|{{math_op_multiplication}}|{{math_op_power}}|{{math_op_remainder}}|{{math_op_root}}|{{math_op_subtraction}})'

  string_op_concatenation: '(?:++)'
  string_op_remove_all: '(?:--)'
  string_op_remove_first: '(?:-<)'
  string_op_remove_last: '(?:->)'
  string_op_replace_all: '(?:\!\!)'
  string_op_replace_first: '(?:\!<)'
  string_op_replace_last: '(?:\!>)'
  string_op_first_index_of: '(?:<<)'
  string_op_last_index_of: '(?:>>)'
  string_op_all_index_of: '(?:><)'
  string_op: '(?:{{string_op_all_index_of}}|{{string_op_concatenation}}|{{string_op_first_index_of}}|{{string_op_last_index_of}}|{{string_op_remove_all}}|{{string_op_remove_first}}|{{string_op_remove_last}}|{{string_op_replace_all}}|{{string_op_replace_first}}|{{string_op_replace_last}})'

  operations: '(?:{{bool_op}}|{{assignment_op}}|{{math_op}}|{{string_op}})'

  unicode_char: '(?:\\u\h{4}|\\U\h{8})'
  escaped_char: '(?:\\[abfnrtv"''\\]|{{unicode_char}}|\\x[0-9a-fA-F]{1,4}|\\[0-9]{1,3})'

  visibility: '\b(?:Public|Private|Visible)\b'
  
  reserved_base_type: '(?:Type|Reference|Node|Pair|Array|Bag|Flag|Number|Guid|Logical|Character|String|Date|Place|Culture|Enumeration|Enum Node)'
  reserved_patterned_type: '(?:Domain|Singleton|Facade|Model|View|Controller|Bridge|Adapter|DataStore|DataProvider|DataAdapter|DataBridge|ForeignService|Service|Application)'
  base_type: '(?:{{reserved_base_type}}|{{reserved_patterned_type}})'

  reserved_decisions: '(?:If|Else|Else[ ]If|End[ ]If|Compare|With|End[ ]With|To|When|End[ ]Compare|Choice|Other|End[ ]Choice)'
  reserved_errors: '(?:Error|Error Scope|Handle|End Handle|Last Error|Throw|Rethrow)'
  reserved_loops: '(?:Each|Within|End Each|Exit|Next|For|Start|End At|Skip|End For|Do|Until|While|End While)'
  reserved: '(?:{{reserved_constructs}}|{{reserved_decisions}}|{{reserved_errors}}|{{reserved_loops}})'

  reserved_objects: '(?:Object|Delegate|Application[ ]Scope|Application|Enumeration|Test[ ]Set|Test|Singleton|Model|Controller|Facade|Bridge|Adapter|Data[ ]Store|Data[ ]Provider|Data[ ]Adapter|Data[ ]Bridge|Remote|Service)'

  start_char: '(?:{{unicode_char}}|[_\p{L}])'
  other_char: '(?:{{unicode_char}}|[_0=9\p{L}])'
  name_normal: '{{start_char}}{{other_char}}*\b'
  cap_name: '(\p{Lu}{{other_char}})'
  name: '(?:@{{reserved}}@{{base_type}}|@var|@?{{name_normal}})'

  type_separator: '>'
  line_terminator: '\.'

contexts:
  prototype:
    - include: comments
    - match: '^(#)(\s+)'
      captures:
        1: keyword.other.preprocessor.pattern
        2: punctuation.definition.preprocessor.pattern
      push: preprocessor_option


  string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.pattern
    - include: escaped
    - match: '"'
      scope: punctuation.definition.string.end.pattern
      pop: true
    - include: string_placeholders
    - match: '$\n?'
      scope: invalid.illegal.unclosed-string.pattern
      pop: true
  
  format_string:
    - meta_include_prototype: false 
    - meta_scope: meta.string.interpolated.pattern string.quoted.double.pattern
    - match: '"'
      scope: punctuation.definition.string.end.pattern
      pop: true
    - include: escaped
    - include: string_placeholder_escape
    - match: '\{'
      scope: punctuation.section.interpolation.begin.pattern
      push:
        - meta_scope: meta.string.interpolated.pattern support.pattern
        - clear_scopes: 2
          pop: true
        - include: string_interpolation
    - match: '$\n?'
      scope: invalid.illegal.unclosed-string.pattern
      pop: true

  long_format_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.interpolated.pattern
    - match: '"""'
      scope: constant.character.escape.pattern
    - match: '"'
      scope: punctuation.definition.string.end.pattern
      pop: true
    - include: string_placeholder_escape
    - match: '\{'
      scope: punctuation.section.interpolation.begin.pattern
      push:
        - meta_scope: meta.string.interpolated.pattern source.pattern
        - clear_scopes: 2
        - include: string_interpolation

  string_placeholders:
    - include: string_placeholder_escape
    - match: '(\{)(\d+)(?=")'
      scope: constant.other.placeholder.pattern
      captures:
        1: punctuation.definition.placeholder.begin.pattern
        2: constant.numeric.pattern invalid.illegal.unclosed-string-placeholder.pattern
    - match: '(\{)(\d+)'
      captures:
        1: punctuation.definition.placeholder.begin.pattern
        2: constant.numeric.pattern
      push: string_placeholder 
  
  string_placeholder:
    - meta_scope: constant.other.placeholder.pattern
    - match: '(\})(\}(?!\{))?'
      captures:
        1: punctuation.definition.placeholder.end.pattern
        2: invalid.illegal.unescaped-placeholder.pattern
      pop: true
    - match: '(?=[}"])'
      pop: true
    - include: string_placeholder_format
    - match: '[^"}]+'
      scope: invalid.illegal.unexpected-character-in-placeholder.pattern

  string_placeholder_format:
    - match: '(?:(,)[ ](-?\d+)[ ])?'
      captures:
        1: punctuation.separator.arguments.pattern
        2: constant.numeric.formatting.pattern
    - match: ':(?="(?!"))'
      scope: invalid.illegal.unclosed-string-placeholder.pattern
      pop: true
    - match: ':'
      scope: punctuation.separator.pattern
      push:
        - meta_scope: constant.other.format-spec.pattern
        - include: string_placeholder_escape
        - include: escaped
        - match: '(?=\})'
          pop: true
        - match: '([^}"\\]+(\\.)*)+(?="(?!"))'
          scope: invalid.illegal.unclosed-string-placeholder.pattern
          pop: true
        - match:
          scope: invalid.illegal.unescaped-placeholder.pattern
  
  string_interpolation:
    - include: string_placeholder_format
    - match: '}'
      scope: punctuation.section.interpolation.end.pattern
      pop: true
    - include: line_of_code_in

  long_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.raw.pattern
    - match: '""'
      scope: constant.character.escape.pattern
    - include: string_placeholders
    - match: '"'
      scope: punctuation.definition.string.end.pattern
      pop: true

  escaped:
    - match: '{{escaped_char}}'
      scope: constant.character.escaped.pattern
    - match: '\\'
      scope: invalid.illegal.lone-escape.pattern
    
  catch_expr:
    - match: '(Handle)(\.)|(?:[ ]|({{named_type}})?'
      captures:
        1: keyword.control.trycatch.catch.pattern
        2: meta.group.pattern punctuation.section.group.begin.pattern
        3: variable.other.namespace.pattern
      push: catch_block
    - include: catch_when
    - match: '(?=\S)'
      pop: true

  try_block:
    - meta_content_scope: meta.group.pattern
    - push: catch_expr
    - push: always_expr
    - match: '^[ ]{6}[ ]*(End[ ]Error[ ]Scope)(\.)'
      captures:
        1: keyword.control.trycatch.catch.pattern
        2: meta.group.pattern punctuation.section.group.begin.pattern
      pop: true
    - include: code_block_in
    - match: (?=\S)
      pop: true

  always_expr:
    - meta_content_scope: meta.group.pattern
    - match: '^[ ]{6}[ ]*Always'
      scope: keyword.control.trycatch.finally.pattern
    - include: finally_block

  trycatch_block:
    - meta_content_scope: meta.group.pattern
    - match: '^[ ]{6}[ ]*(?=(Handle|Always))'
      captures: 
        1: storage.type.pattern
        2: meta.group.pattern punctuation.section.group.end.pattern
      pop: true
    - include: code_block_in
    - match: (?=\S)
      pop: true

  catch_block:
    - match: '\bWhen\b'
      scope: keyword.control.trycatch.when.pattern
      push: if_condition
      set: trycatch_block  

  finally_block:
    - meta_scope: meta.block.trycatch.pattern
    - match: 'Always\b'
      scope: keyword.control.trycatch.finally.pattern
      set: trycatch_block
    - match: '(?=\S)'
      pop: true

  using_block:
    - meta_content_scope: meta.group.pattern
    - match: '\n'
      scope: meta.group.pattern punctuation.section.group.end.pattern
      set:
        - match: '^[[:blank:]]'
          scope: punctuation.section.block.begin.pattern
          set:
            - meta_scope: meta.block.pattern
            - match: '^'
              scope: punctuation.section.block.end.pattern
              pop: true
            - include: code_block_in
        - match: '(?=\S)'
          pop: true
    - match: (?=\S)
      pop: true

  expression_block:
    - meta_content_scope: meta.group.pattern
    - match: '\)'
      scope: meta.group.pattern punctuation.section.group.end.pattern
      set:
        - match: '^'
          scope: meta.block.pattern punctuation.section.block.begin.pattern
          set:
            - meta_content_scope: meta.block.pattern
            - match: '^$'
              scope: meta.block.pattern punctuation.section.block.end.pattern
              pop: true
            - include: code_block_in
        - match: '(?=\S)'
          set: line_of_code

  if_condition:
    - match: '([ ])'
      captures:
        1: meta.group.pattern punctuation.section.group.begin.pattern
      set:
        - meta_content_scope: meta.group.pattern
        - match: '(\n)'
          captures:
            1: meta.group.pattern punctuation.section.group.end.pattern
          pop: true 
        - include: line_of_code_in
    - match: '(?=[^(])'
      pop: true 

  if_block:
    - match: '^'
      scope: meta.block.pattern punctuation.section.block.begin.pattern
      set:
        - meta_content_scope: meta.block.pattern
        - match: '\^$'
          scope: meta.block.pattern punctuation.section.block.end.pattern
          pop: true
        - include: main 
    - match: '(?=\S)'
      set:
        - match: '(?=Else\b)'
          pop: true 
        - include: line_of_code

  else_block:
    - match: '(Else\sIf)\b'
      captures:
        1: keyword.control.conditional.elseif.pattern
      push: [if_block, if_condition]
    - match: '(Else)\n'
      scope: keyword.control.conditional.else.pattern 
      set:
        - match: '^'
          captures:
            1: meta.block.pattern punctuation.section.block.begin.pattern
          set:
            - meta_content_scope: meta.block.pattern
            - match: '^$'
              scope: meta.block.pattern punctuation.section.block.end.pattern
              pop: true 
            - include: main 
        - match: '(?=\S)'
          set:
            - include: line_of_code
    - match: '(?=\S)'
      pop: true 

  switch_condition:
    - match: '[ ]'
      scope: punctuation.section.group.begin.pattern
      set:
        - meta_scope: meta.group.pattern
        - match: '^$'
          scope: punctuation.section.group.end.pattern
          pop: true 
        - include: line_of_code_in
    - match: '(?=\S)'
      pop: true 
  
  switch_block:
    - match: '^[[:blank:]]'
      scope: punctuation.section.block.begin.pattern
      set:
        - meta_scope: meta.block.pattern
        - match: '^$'
          scope: punctuation.section.block.end.pattern
          pop: true
        - match: '\b(Otherwise)'
          captures:
            1: keyword.control.switch.case.pattern
        - match: '\b(When)\b'
          scope: keyword.control.switch.case.pattern
          push:
            - match: '{{name}}'
              scope: constant.other.pattern 
            - match: '\bUpon\b'
              scope: keyword.control.switch.case.when.pattern
            - match: '(?={{name}}{{type_suffix}}[ ]{{name}}\sUpon\b'
              push: var_declaration_explicit
            - match: '^[[:blank:]]'
              scope: punctuation.separator.case-statement.pattern 
              pop: true 
            - include: line_of_code_in 
            - match: '$'
              pop: true 
        - include: code_block_in
    - match: '(?=\S)'
      pop: true 

  for_var_assignment:
    - match: '='
      scope: keyword.operator.assignment.variable.loop.pattern
      set: line_of_code_in 
    - match: '(?=^[[:blank:]]|\r)'
      pop: true 

  foreach_var_assignment:
    - match: 'In'
      scope: keyword.operator.assignment.variable.loop.pattern
      set: line_of_code_in
    - match: '(?=^[[:blank:]]|\r)'
      pop: true 

  var_declaration:
    - match: '(Constant|Mutable)[ ]({{name}})[ ]'
      captures:
        1: storage.type.variable.pattern
        2: variable.other.pattern
      pop: true 
  
  using_var_assignment:
    - match: '='  
      scope: keyword.operator.assignment.variable.using.pattern
      push: line_of_code_in
    - match: '(?=^[[:blank:]]|\r)'
      pop: true
    - match: ','
      scope: punctuation.separator.expression.pattern
      push: line_of_code_in

  for_block:
    - meta_content_scope: meta.group.pattern
      match: '$^'
      scope: punctuation.section.group.end.pattern
      set:
      - match: '^[[:blank:]]'
        scope: punctuation.section.block.end.pattern
        set:
          - meta_scope: meta.block.pattern
          - match: '^$'
            scope: punctuation.section.block.end.pattern
            pop: true 
          - include: code_block_in
      - match: (?=\S)
        set:
          - include: line_of_code

  while_block:
    - match: '^[[:blank:]]'
      scope: punctuation.section.block.begin.pattern
      set:
        - meta_scope: meta.block.pattern
        - match: '^$' 
          scope: punctuation.section.block.end.pattern
          pop: true 
        - include: line_of_code_in
    - match: '(?=\S)'
      set:
        - include: line_of_code

  do_condition:
    - match: '\b(Until)\b'
      scope: keyword.control.loop.while.pattern
      set: while_condition 
    - match: '(?=\S)'
      pop: true 

  while_condition:
    - match: '[ ]'
      scope: punctuation.section.group.begin.pattern
      set:
        - meta_scope: meta.group.pattern
        - match: '\n'
          scope: punctuation.section.group.end.pattern
          pop: true 
        - include: line_of_code_in
    - match: '(?=\S)'
      pop: true 

  documentation:
    - meta_include_prototype: false 
    - meta_content_scope: comment.block.documentation.pattern
    - match: '(<)({{name}})'
      captures:
        1: punctuation.definition.tag.begin.pattern
        2: entity.name.tag.begin.pattern
      push:
        - meta_include_prototype: false 
        - match: '({{name}})[ ](=)'
          captures:
            1: entity.other.attribute-name.pattern
            2: punctuation.separator.argument.value.pattern
        - match: '/?>'
          scope: punctuation.definition.tag.end.pattern
          pop: true 
        - match: '"[^"]*"'
          scope: string.quoted.double.pattern
        - match: '(</)({{name}})(>)'
          captures:
            1: puncutation.definition.tag.begin.pattern
            2: entity.name.tag.end.pattern
            3: punctuation.definition.tag.end.pattern
        - match: '^\s*(///)'
          captures:
            1: punctuation.definition.comment.documentation.pattern
        - match: '^\s*(?!///)'
          pop: true
        - include: comments_in
        - match: '[\w\s]+|.'
          scope: text.documentation.patternf